\chapter{Implementierung}
\label{cha:A}

Die Implementierung aller Funktionen erfolgte im \MATLAB R2016a. In diesem Abschnitt werden einige implementierte Funktionen aufgeführt und kurz erläutert. Wegen einer hohen Zeilenanzahl einiger Quellcodes, können sie nicht in voller Länge hier präsentiert werden. Für volle Quellcodes sei man hier auf die beigelegte CD verwiesen.

\section{Radon Transformation}
\label{cha:A.1}

Die Radon Transformation wurde entsprechend der Gleichung (\ref{equa:3.3}) implementiert. 

\begin{lstlisting}[style=Matlab-editor,basicstyle=\color{black}\ttfamily\footnotesize, backgroundcolor=\color{white}]
function [ sinogramm ] = radonTrafo( pic, angles, detWide )
	
	... % some argument preparation 
	
	sinogramm = zeros( detWide, length(angles) );
	
	% loop over all angles
	for i = 1:anglesNumber
		% addition of 90 degrees prevents the phase shift of the sinogram
		rotImg = imrotate( pic, angles(i)+90, 'bilinear', method );      
		
		% The difference is here, that for small picture sizes the summation
		% has a better result than the trapez integration. Trapez is
		% another case, which is for big size pictures better.
		if( smallSize )  
			layer = sum( rotImg, 2 );      
		else      
			layer = trapz( rotImg, 2 );    
		end
		
		... % some index preparation for output
		
		if( detWide < h )
			sinogramm( :, i ) = layer(dist:h - b);
		else
			sinogramm( dist:h + dist-1, i ) = layer;
		end
	end % endFor i
end % end radonTrafo()  
\end{lstlisting}
\vspace{12pt}
Betrachten wir die Zeile 10 in der Funktion \verb|radonTrafo()|. Hier wird das Argument \verb|pic| für jeden Winkel \verb|angles(i)| rotiert. Dies entspricht der Durchstrahlung eines Objekts unter einem Winkel $\theta$. Da hier nur parallelgeometrische Strahlengänge behandelt werden, kann somit das rotierte Bild \verb|pic| entlang ihrer Zeilenpixel aufsummiert werden. Was auch der Summe in (\ref{equa:3.3}) gleichen würde. In der Zeile 29/31 wird die Spalte des Sinogramms \verb|sinogramm| an der entsprechenden Stelle \verb|i| mit dem Summenvektor \verb|layer| ergänzt.

\section{Ungefilterte Rückprojektion}
\label{cha:A.2}

Die Implementierung der ungefilterten Rückprojektion erfolgte entsprechend der Formel (\ref{equa:1.21}). Jedoch passiert die Rückprojizierung gleich für alle Pixel pro Winkel. 

\begin{lstlisting}[style=Matlab-editor,basicstyle=\color{black}\ttfamily\footnotesize, backgroundcolor=\color{white}]
function [ output ] = backProjection( sinogram, angels )
	
	anglesNumber  = length(angels); 
	
	% size for output
	[ numberOfProjections, ~ ] = size( sinogram );
	output = zeros( numberOfProjections, numberOfProjections );
	
	% descrete euklid coordinates, only one axis is needed, because
	% the grid will be square. 
	[x] = meshgrid(ceil(-numberOfProjections/2):ceil(numberOfProjections/2-1));
	
	% find the middle 
	middle = floor( numberOfProjections/2 ) + 1;
	
	% back projection
	for i = 1:anglesNumber
		% rotate the coordinates and shift back
		direction = round(middle + x*sind(angels(i)+90) + x'*cosd(angels(i)+90));
		
		% indicate the pixels in which the backprojection will be written
		indices   = find(( direction > 0 )&( direction <= numberOfProjections ));
		
		% sum of backprojecktions
		output(indices) = output(indices) + ...
			sinogram(direction(indices),i)./anglesNumber;
	end % endFor i
end % end backProjection() 
\end{lstlisting}
\vspace{12pt}
Die Größe von \verb|output| entspricht (\ref{equa:3.2}), also der Detektorbreite, was in diesem Falle die Zeilenanzahl des Sinogramms ist (Zeile 6, 7). In der Zeile 19 wird das erzeugte Koordinatensystem \verb|x| (Zeile 11) gedreht und verschoben. Die Verschiebung der Koordinaten sorgt dafür, dass die Indizierung (Zeile 22) die Breite des Detektors bei Drehung beibehält. In der Zeile 25/26 wird \verb|output| an den entsprechenden Stellen \verb|indices| aufaddiert.

\section{Gefilterte Rückprojektion}
\label{cha:A.3}
Der unten aufgeführter Codeabschnitt implementiert die gefilterte Rückprojektion. Die ausgelassenen Codeteile entsprechen genau dem Code der ungefilterten Rückprojektion von \ref{cha:A.2}.

\begin{lstlisting}[style=Matlab-editor,basicstyle=\color{black}\ttfamily\footnotesize, backgroundcolor=\color{white}]
function [ output ] = filteredBackProjection( sinogram, angels, filter )
	
	... % some parameter preparations
		
	% if no filter is given, than a ramp filter will be created 
	if( nargin < 3 )
		filter = [floor(numberOfProjections/2):-1:0 1:ceil(numberOfProjections/2-1)]*2;
	end
	
	% back projection
	for i = 1:anglesNumber
	
		% filtering part before back projection
		% ------------------------------------------------------------------
		inpFT = ifftshift( fft( sinogram(:,anglesNumber-i+1)' ) );        
		% filtering in Fourier-Space is only multiplication:        
		filteredProjection = filter.*inpFT;
		filteredProjection = real( ifft( fftshift( filteredProjection' ) ) );
		% ------------------------------------------------------------------
		
		... % back projection of filteredProjection
		
	end % endFor i
end % end backProjection() 
\end{lstlisting}
\vspace{12pt}
In Zeile 7 wird eine kleine Absicherung eingeschaltet, falls kein Filter mitgeteilt wurde, so initialisiert die Funktion die Variable \verb|filter| standardmäßig mit einem Rampenfilter. Zeile 15-18 ist die eigentliche Filterung der Projektionen. Ein kleiner Trick wurde hier angewendet. Die schnelle FT (\verb|fft()|) liefert im \MATLAB ein verschobenes Spektrum, sodass er mittels \verb|ifftshift()| zurück verschoben werden muss. Nach der Filterung (Zeile 17) wird die schon gefilterte Projektion entsprechend verschoben und mit \verb|ifft()| invers Fouriertransformiert. Danach passiert nur noch die Rückprojektion, wie in \verb|backProjection()|.

\section{Erzeugung der Systemmatrix von $\mathcal{R}$}
\label{cha:A.4}

Die Implementierung der Funktion \verb|getSysMat()| (siehe CD-ROM) baut auf der Implementierung der Funktion \verb|paralleltomo()| von \cite{Hansen} auf. Wobei die Funktion \verb|paralleltomo()| für hier nötige Zwecke eingeschränkt und neu implementiert wurde. 

\section{Iterative Rekonstruktion nach Kaczmarz}
\label{cha:A.5}

Der iterative Algorithmus ist in der Funktion \verb|iterativeReconstruction()| implementiert. Der Kernteil der Funktion (Zeile 12-32) läuft über eine $while$-Schleife, daher man eine Abbruchbedingung, die wie folgt definiert werden kann
\begin{equation} 
	||Af_t - p ||_2 \leq \delta. 
	\label{equa:A.1}
\end{equation}

Das heißt, wir erwarten eine Verbesserung von $f_t$ nach jeder Iteration, so das die neue Projektion $Af_t$ immer näher an $p$ liegen soll und daher sich die Fehlernorm verringern soll. Anschließend wird der Fehler mit einer Schranke $\delta$ verglichen. Diese setzt sich aus dem Datenfehler $|| \tilde{p} - p ||_2 = \epsilon$ und einer Konstante $\alpha \geq 1$ zusammen, also $\delta = \alpha\epsilon$. Die Konstante $\alpha$ wird größer/gleich Eins gesetzt, weil man nicht erwarten kann, dass der Fehler in der Rekonstruktion kleiner als Datenfehler wird. 

\begin{lstlisting}[style=Matlab-editor,basicstyle=\color{black}\ttfamily\footnotesize, backgroundcolor=\color{white}]
function [output, iter] = iterativeReconstruction( sinogram, angels, maxIterNr, delta, randPar, sysMat )

	... % some parameter preparation
	
	while( stop > delta && maxIterNr > iter )      
		if(strcmp(randPar, 'random'))
			% creates randomized index vector for iteration
			iterVec = randperm(M);
		else
			iterVec = 1:M;
		end		
		% here Kaczmarz algorithm
		for i = iterVec
			ai = sysMat(:,i); 
			output = output + relax*((projections(i)-ai'*output)/sum(ai.*ai,1))*ai;            
		end  
		% stop rule $||Af_i - p||_2$
		stop = norm(sysMat'*output - projections);       
		iter = iter + 1;               
	end % endWhile
	% transform the output into a matrix
	output = vec2mat( output, detectorSize );
	
	... % some output perparation
	
end % end iterativeReconstruction()
\end{lstlisting}
\vspace{12pt}
In den Zeilen 6-11 wird anhand des Parameters \verb|randPar| die Art der Berechnung eingestellt, also ob es randomisiert oder vorwärts projektiv gerechnet werden soll. In Zeile 13-16 wird über alle Hyperebenen iteriert, der Ausdruck in Zeile 15 entspricht genau (\ref{equa:3.25}). In der Zeile 18 wird die Norm, wie oben beschrieben berechnet und für den Abbruch der \textit{while}-Schleife benutzt. Die \textit{while}-Schleife wird auch abgebrochen, falls die vorgegebene Anzahl der Iterationen überschritten wird (Zeile 5).


\section{Rekonstruktion durch SWZ}
\label{cha:A.6}

Die Funktion \verb|svdReconstruction()| mit oder ohne der SWZ der Systemmatrix ausgeführt werden. Falls auch die Systemmatrix nicht übergeben wird, so wird die Matrix mittels \verb|getSysMat()| erzeugt und anschließend das singuläre System mit der \MATLAB Funktion \verb|svd()| berechnet.

In den Zeilen 6/7 werden zunächst die Singulärwerte extrahiert und anschließend in der Zeile 10 mittels (\ref{equa:3.31}) regularisiert. Für die Regularisierungswerte wird keine neue Matrix erzeugt, sie werden an die Stellen der Singulärwerte in die Matrix \verb|S| reingeschrieben (Zeile 11). Die Pseudoinverse wird in der Zeile 14 mittels (\ref{equa:3.28}) erzeugt und damit schließlich die Gleichung (\ref{equa:3.26}) in der Zeile 17 gelöst.

\begin{lstlisting}[style=Matlab-editor,basicstyle=\color{black}\ttfamily\footnotesize, backgroundcolor=\color{white}]
function output = svdReconstruction(sinogram, angels, lambda, sysMat, U, S, V)
	
	... some parameter preparation
	
	% preparation for regularization
	ind = S ~= 0;    
	sigma = S( ind );
	
	% thikonov regularization
	sigma = (sigma)./( lambda^2 + sigma.^2 );
	S( ind ) = sigma;
	
	% take the pseudo inverse of sysMat
	pseudoInvers = V*S'*U';
	
	% calculate solution
	output = pseudoInvers*projections;
	
	...some output preparation
	
end % end svdReconstruction()
\end{lstlisting}

